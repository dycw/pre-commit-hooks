#!/usr/bin/env bash
# shellcheck source=/dev/null

run_all_hooks() {
	root=$(git rev-parse --show-toplevel)

	if [ -d "$root/hooks" ]; then
		# development
		hooks_dir="$root/hooks"
	elif [ -d "$root/.pre-commit-hooks/hooks" ]; then
		# deployment
		hooks_dir="$root/.pre-commit-hooks/hooks"
	else
		printf "ERROR: hooks directory missing\n"
		return 1
	fi
	declare -a all_hooks
	while read -r hook; do
		all_hooks+=("$hook")
	done <<<"$(find "$hooks_dir" -type f)"

	staged_names=$(git diff --name-only --cached)
	if [ -z "$staged_names" ]; then
		return 0
	fi
	declare -a all_files
	while read -r staged_name; do
		staged_path="$root/$staged_name"
		if [ -f "$staged_path" ]; then
			all_files+=("$staged_path")
		elif [ -d "$staged_path" ]; then
			while read -r name_in_dir; do
				all_files+=("$root/$name_in_dir")
			done <<<"$(git ls-all_files "$root"/"$staged_path")"
		fi
	done <<<"$staged_names"

	code=0
	for hook in "${all_hooks[@]}"; do
		for file in "${all_files[@]}"; do
			if [[ -n "$PRE_COMMIT_DEBUG" ]]; then
				hook_name=$(basename "$hook")
				file_rel=$(realpath --relative-to="$root" "$file")
				printf "running %s on %s\n" "$hook_name" "$file_rel"
			fi
			if ! "$hook" "$file"; then
				code=1
			fi
		done
	done

	if [ -n "$(git diff --name-only --cached)" ]; then
		return $code
	else
		return 0
	fi
}

run_all_hooks
exit $?
